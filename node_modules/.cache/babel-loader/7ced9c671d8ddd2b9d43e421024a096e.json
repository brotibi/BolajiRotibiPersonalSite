{"ast":null,"code":"\"use strict\";\n\nvar React = require('react');\n\nvar PropTypes = require('prop-types');\n\nvar assign = Object.assign || require('object-assign');\n/**\n * Mixin for routers which implements the simplest rendering strategy.\n */\n\n\nvar RouteRenderingMixin = {\n  propTypes: {\n    childProps: PropTypes.object\n  },\n  // Props passed at the `childProps` key are passed to all handlers.\n  getChildProps: function () {\n    var childProps = this.props.childProps || {}; // Merge up from parents, with inner props taking priority.\n\n    var parent = this.getParentRouter();\n\n    if (parent) {\n      childProps = assign({}, parent.getChildProps(), childProps);\n    }\n\n    return childProps;\n  },\n  renderRouteHandler: function () {\n    if (!this.state.match.route) {\n      throw new Error(\"React-router-component: No route matched! Did you define a NotFound route?\");\n    }\n\n    var handler = this.state.handler;\n    var isDOMElement = typeof handler.type === 'string'; // If this is a DOM element, don't send these props. This won't prevent all\n    // warnings in 15.2.0, but it will catch a lot of them.\n\n    var matchProps = isDOMElement ? null : this.state.matchProps;\n    var outProps = assign({\n      ref: this.state.match.route.ref\n    }, this.getChildProps(), matchProps); // If we were passed an element, we need to clone it before passing it along.\n\n    if (React.isValidElement(handler)) {\n      // Be sure to keep the props that were already set on the handler.\n      // Otherwise, a handler like <div className=\"foo\">bar</div> would have its className lost.\n      return React.cloneElement(handler, assign(outProps, handler.props));\n    }\n\n    return React.createElement(handler, outProps);\n  }\n};\nmodule.exports = RouteRenderingMixin;","map":null,"metadata":{},"sourceType":"script"}