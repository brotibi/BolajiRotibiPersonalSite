{"ast":null,"code":"// Generated by CoffeeScript 1.10.0\nvar slice = [].slice;\n\n(function (root, factory) {\n  if ('function' === typeof define && define.amd != null) {\n    return define([], factory);\n  } else if (typeof exports !== \"undefined\" && exports !== null) {\n    return module.exports = factory();\n  } else {\n    return root.UrlPattern = factory();\n  }\n})(this, function () {\n  var P, UrlPattern, astNodeContainsSegmentsForProvidedParams, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultOptions, escapeForRegex, getParam, keysAndValuesToObject, newParser, regexGroupCount, stringConcatMap, stringify;\n\n  escapeForRegex = function (string) {\n    return string.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n  };\n\n  concatMap = function (array, f) {\n    var i, length, results;\n    results = [];\n    i = -1;\n    length = array.length;\n\n    while (++i < length) {\n      results = results.concat(f(array[i]));\n    }\n\n    return results;\n  };\n\n  stringConcatMap = function (array, f) {\n    var i, length, result;\n    result = '';\n    i = -1;\n    length = array.length;\n\n    while (++i < length) {\n      result += f(array[i]);\n    }\n\n    return result;\n  };\n\n  regexGroupCount = function (regex) {\n    return new RegExp(regex.toString() + '|').exec('').length - 1;\n  };\n\n  keysAndValuesToObject = function (keys, values) {\n    var i, key, length, object, value;\n    object = {};\n    i = -1;\n    length = keys.length;\n\n    while (++i < length) {\n      key = keys[i];\n      value = values[i];\n\n      if (value == null) {\n        continue;\n      }\n\n      if (object[key] != null) {\n        if (!Array.isArray(object[key])) {\n          object[key] = [object[key]];\n        }\n\n        object[key].push(value);\n      } else {\n        object[key] = value;\n      }\n    }\n\n    return object;\n  };\n\n  P = {};\n\n  P.Result = function (value, rest) {\n    this.value = value;\n    this.rest = rest;\n  };\n\n  P.Tagged = function (tag, value) {\n    this.tag = tag;\n    this.value = value;\n  };\n\n  P.tag = function (tag, parser) {\n    return function (input) {\n      var result, tagged;\n      result = parser(input);\n\n      if (result == null) {\n        return;\n      }\n\n      tagged = new P.Tagged(tag, result.value);\n      return new P.Result(tagged, result.rest);\n    };\n  };\n\n  P.regex = function (regex) {\n    return function (input) {\n      var matches, result;\n      matches = regex.exec(input);\n\n      if (matches == null) {\n        return;\n      }\n\n      result = matches[0];\n      return new P.Result(result, input.slice(result.length));\n    };\n  };\n\n  P.sequence = function () {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function (input) {\n      var i, length, parser, rest, result, values;\n      i = -1;\n      length = parsers.length;\n      values = [];\n      rest = input;\n\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(rest);\n\n        if (result == null) {\n          return;\n        }\n\n        values.push(result.value);\n        rest = result.rest;\n      }\n\n      return new P.Result(values, rest);\n    };\n  };\n\n  P.pick = function () {\n    var indexes, parsers;\n    indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    return function (input) {\n      var array, result;\n      result = P.sequence.apply(P, parsers)(input);\n\n      if (result == null) {\n        return;\n      }\n\n      array = result.value;\n      result.value = array[indexes];\n      return result;\n    };\n  };\n\n  P.string = function (string) {\n    var length;\n    length = string.length;\n    return function (input) {\n      if (input.slice(0, length) === string) {\n        return new P.Result(string, input.slice(length));\n      }\n    };\n  };\n\n  P.lazy = function (fn) {\n    var cached;\n    cached = null;\n    return function (input) {\n      if (cached == null) {\n        cached = fn();\n      }\n\n      return cached(input);\n    };\n  };\n\n  P.baseMany = function (parser, end, stringResult, atLeastOneResultRequired, input) {\n    var endResult, parserResult, rest, results;\n    rest = input;\n    results = stringResult ? '' : [];\n\n    while (true) {\n      if (end != null) {\n        endResult = end(rest);\n\n        if (endResult != null) {\n          break;\n        }\n      }\n\n      parserResult = parser(rest);\n\n      if (parserResult == null) {\n        break;\n      }\n\n      if (stringResult) {\n        results += parserResult.value;\n      } else {\n        results.push(parserResult.value);\n      }\n\n      rest = parserResult.rest;\n    }\n\n    if (atLeastOneResultRequired && results.length === 0) {\n      return;\n    }\n\n    return new P.Result(results, rest);\n  };\n\n  P.many1 = function (parser) {\n    return function (input) {\n      return P.baseMany(parser, null, false, true, input);\n    };\n  };\n\n  P.concatMany1Till = function (parser, end) {\n    return function (input) {\n      return P.baseMany(parser, end, true, true, input);\n    };\n  };\n\n  P.firstChoice = function () {\n    var parsers;\n    parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];\n    return function (input) {\n      var i, length, parser, result;\n      i = -1;\n      length = parsers.length;\n\n      while (++i < length) {\n        parser = parsers[i];\n        result = parser(input);\n\n        if (result != null) {\n          return result;\n        }\n      }\n    };\n  };\n\n  newParser = function (options) {\n    var U;\n    U = {};\n    U.wildcard = P.tag('wildcard', P.string(options.wildcardChar));\n    U.optional = P.tag('optional', P.pick(1, P.string(options.optionalSegmentStartChar), P.lazy(function () {\n      return U.pattern;\n    }), P.string(options.optionalSegmentEndChar)));\n    U.name = P.regex(new RegExp(\"^[\" + options.segmentNameCharset + \"]+\"));\n    U.named = P.tag('named', P.pick(1, P.string(options.segmentNameStartChar), P.lazy(function () {\n      return U.name;\n    })));\n    U.escapedChar = P.pick(1, P.string(options.escapeChar), P.regex(/^./));\n    U[\"static\"] = P.tag('static', P.concatMany1Till(P.firstChoice(P.lazy(function () {\n      return U.escapedChar;\n    }), P.regex(/^./)), P.firstChoice(P.string(options.segmentNameStartChar), P.string(options.optionalSegmentStartChar), P.string(options.optionalSegmentEndChar), U.wildcard)));\n    U.token = P.lazy(function () {\n      return P.firstChoice(U.wildcard, U.optional, U.named, U[\"static\"]);\n    });\n    U.pattern = P.many1(P.lazy(function () {\n      return U.token;\n    }));\n    return U;\n  };\n\n  defaultOptions = {\n    escapeChar: '\\\\',\n    segmentNameStartChar: ':',\n    segmentValueCharset: 'a-zA-Z0-9-_~ %',\n    segmentNameCharset: 'a-zA-Z0-9',\n    optionalSegmentStartChar: '(',\n    optionalSegmentEndChar: ')',\n    wildcardChar: '*'\n  };\n\n  baseAstNodeToRegexString = function (astNode, segmentValueCharset) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function (node) {\n        return baseAstNodeToRegexString(node, segmentValueCharset);\n      });\n    }\n\n    switch (astNode.tag) {\n      case 'wildcard':\n        return '(.*?)';\n\n      case 'named':\n        return \"([\" + segmentValueCharset + \"]+)\";\n\n      case 'static':\n        return escapeForRegex(astNode.value);\n\n      case 'optional':\n        return '(?:' + baseAstNodeToRegexString(astNode.value, segmentValueCharset) + ')?';\n    }\n  };\n\n  astNodeToRegexString = function (astNode, segmentValueCharset) {\n    if (segmentValueCharset == null) {\n      segmentValueCharset = defaultOptions.segmentValueCharset;\n    }\n\n    return '^' + baseAstNodeToRegexString(astNode, segmentValueCharset) + '$';\n  };\n\n  astNodeToNames = function (astNode) {\n    if (Array.isArray(astNode)) {\n      return concatMap(astNode, astNodeToNames);\n    }\n\n    switch (astNode.tag) {\n      case 'wildcard':\n        return ['_'];\n\n      case 'named':\n        return [astNode.value];\n\n      case 'static':\n        return [];\n\n      case 'optional':\n        return astNodeToNames(astNode.value);\n    }\n  };\n\n  getParam = function (params, key, nextIndexes, sideEffects) {\n    var index, maxIndex, result, value;\n\n    if (sideEffects == null) {\n      sideEffects = false;\n    }\n\n    value = params[key];\n\n    if (value == null) {\n      if (sideEffects) {\n        throw new Error(\"no values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n\n    index = nextIndexes[key] || 0;\n    maxIndex = Array.isArray(value) ? value.length - 1 : 0;\n\n    if (index > maxIndex) {\n      if (sideEffects) {\n        throw new Error(\"too few values provided for key `\" + key + \"`\");\n      } else {\n        return;\n      }\n    }\n\n    result = Array.isArray(value) ? value[index] : value;\n\n    if (sideEffects) {\n      nextIndexes[key] = index + 1;\n    }\n\n    return result;\n  };\n\n  astNodeContainsSegmentsForProvidedParams = function (astNode, params, nextIndexes) {\n    var i, length;\n\n    if (Array.isArray(astNode)) {\n      i = -1;\n      length = astNode.length;\n\n      while (++i < length) {\n        if (astNodeContainsSegmentsForProvidedParams(astNode[i], params, nextIndexes)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, false) != null;\n\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, false) != null;\n\n      case 'static':\n        return false;\n\n      case 'optional':\n        return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);\n    }\n  };\n\n  stringify = function (astNode, params, nextIndexes) {\n    if (Array.isArray(astNode)) {\n      return stringConcatMap(astNode, function (node) {\n        return stringify(node, params, nextIndexes);\n      });\n    }\n\n    switch (astNode.tag) {\n      case 'wildcard':\n        return getParam(params, '_', nextIndexes, true);\n\n      case 'named':\n        return getParam(params, astNode.value, nextIndexes, true);\n\n      case 'static':\n        return astNode.value;\n\n      case 'optional':\n        if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {\n          return stringify(astNode.value, params, nextIndexes);\n        } else {\n          return '';\n        }\n\n    }\n  };\n\n  UrlPattern = function (arg1, arg2) {\n    var groupCount, options, parsed, parser, withoutWhitespace;\n\n    if (arg1 instanceof UrlPattern) {\n      this.isRegex = arg1.isRegex;\n      this.regex = arg1.regex;\n      this.ast = arg1.ast;\n      this.names = arg1.names;\n      return;\n    }\n\n    this.isRegex = arg1 instanceof RegExp;\n\n    if (!('string' === typeof arg1 || this.isRegex)) {\n      throw new TypeError('argument must be a regex or a string');\n    }\n\n    if (this.isRegex) {\n      this.regex = arg1;\n\n      if (arg2 != null) {\n        if (!Array.isArray(arg2)) {\n          throw new Error('if first argument is a regex the second argument may be an array of group names but you provided something else');\n        }\n\n        groupCount = regexGroupCount(this.regex);\n\n        if (arg2.length !== groupCount) {\n          throw new Error(\"regex contains \" + groupCount + \" groups but array of group names contains \" + arg2.length);\n        }\n\n        this.names = arg2;\n      }\n\n      return;\n    }\n\n    if (arg1 === '') {\n      throw new Error('argument must not be the empty string');\n    }\n\n    withoutWhitespace = arg1.replace(/\\s+/g, '');\n\n    if (withoutWhitespace !== arg1) {\n      throw new Error('argument must not contain whitespace');\n    }\n\n    options = {\n      escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,\n      segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,\n      segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,\n      segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,\n      optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar,\n      optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,\n      wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar\n    };\n    parser = newParser(options);\n    parsed = parser.pattern(arg1);\n\n    if (parsed == null) {\n      throw new Error(\"couldn't parse pattern\");\n    }\n\n    if (parsed.rest !== '') {\n      throw new Error(\"could only partially parse pattern\");\n    }\n\n    this.ast = parsed.value;\n    this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));\n    this.names = astNodeToNames(this.ast);\n  };\n\n  UrlPattern.prototype.match = function (url) {\n    var groups, match;\n    match = this.regex.exec(url);\n\n    if (match == null) {\n      return null;\n    }\n\n    groups = match.slice(1);\n\n    if (this.names) {\n      return keysAndValuesToObject(this.names, groups);\n    } else {\n      return groups;\n    }\n  };\n\n  UrlPattern.prototype.stringify = function (params) {\n    if (params == null) {\n      params = {};\n    }\n\n    if (this.isRegex) {\n      throw new Error(\"can't stringify patterns generated from a regex\");\n    }\n\n    if (params !== Object(params)) {\n      throw new Error(\"argument must be an object or undefined\");\n    }\n\n    return stringify(this.ast, params, {});\n  };\n\n  UrlPattern.escapeForRegex = escapeForRegex;\n  UrlPattern.concatMap = concatMap;\n  UrlPattern.stringConcatMap = stringConcatMap;\n  UrlPattern.regexGroupCount = regexGroupCount;\n  UrlPattern.keysAndValuesToObject = keysAndValuesToObject;\n  UrlPattern.P = P;\n  UrlPattern.newParser = newParser;\n  UrlPattern.defaultOptions = defaultOptions;\n  UrlPattern.astNodeToRegexString = astNodeToRegexString;\n  UrlPattern.astNodeToNames = astNodeToNames;\n  UrlPattern.getParam = getParam;\n  UrlPattern.astNodeContainsSegmentsForProvidedParams = astNodeContainsSegmentsForProvidedParams;\n  UrlPattern.stringify = stringify;\n  return UrlPattern;\n});","map":null,"metadata":{},"sourceType":"script"}