{"ast":null,"code":"\"use strict\";\n\nvar URLPattern = require('url-pattern');\n\nvar invariant = require('./util/invariant');\n\nvar warning = require('./util/warning');\n\nvar React = require('react');\n\nvar assign = Object.assign || require('object-assign');\n\nvar omit = require('object.omit');\n\nvar qs = require('qs');\n\nvar patternCache = {};\n/**\n * Match routes against a path\n *\n * @param {Array.<Route>}  routes                  Available Routes.\n * @param {String}         path                    Path to match.\n * @param {Object}         [query]                 A parsed query-string object. (from a parent Match)\n * @param {[Object|Array]} [routerURLPatternOptions] URLPattern options from parent router (and its parent and so on).\n */\n\nfunction matchRoutes(routes, path, query, routerURLPatternOptions) {\n  var match,\n      page,\n      notFound,\n      queryObj = query,\n      urlPatternOptions;\n\n  if (!Array.isArray(routes)) {\n    routes = [routes];\n  }\n\n  path = path.split('?');\n  var pathToMatch = path[0];\n  var queryString = path[1];\n\n  if (queryString) {\n    queryObj = qs.parse(queryString);\n  }\n\n  for (var i = 0, len = routes.length; i < len; i++) {\n    var current = routes[i]; // Simply skip null or undefined to allow ternaries in route definitions\n\n    if (!current) continue;\n    invariant(current.props.handler !== undefined && current.props.path !== undefined, \"Router should contain either Route or NotFound components as routes\");\n\n    if (current.props.path) {\n      // Allow passing compiler options to url-pattern, see\n      // https://github.com/snd/url-pattern#customize-the-pattern-syntax\n      // Note that this blows up if you provide an empty object on a regex path\n      urlPatternOptions = null;\n\n      if (Array.isArray(current.props.urlPatternOptions) || current.props.path instanceof RegExp) {\n        // If an array is passed, it takes precedence - assumed these are regexp keys\n        urlPatternOptions = current.props.urlPatternOptions;\n      } else if (routerURLPatternOptions || current.props.urlPatternOptions) {\n        urlPatternOptions = assign({}, routerURLPatternOptions, current.props.urlPatternOptions);\n      } // matchKeys is deprecated\n      // FIXME remove this block in next minor version\n\n\n      if (current.props.matchKeys) {\n        urlPatternOptions = current.props.matchKeys;\n        warning(false, '`matchKeys` is deprecated; please use the prop `urlPatternOptions` instead. See the CHANGELOG for details.');\n      }\n\n      var cacheKey = current.props.path + (urlPatternOptions ? JSON.stringify(urlPatternOptions) : '');\n      var pattern = patternCache[cacheKey];\n\n      if (!pattern) {\n        pattern = patternCache[cacheKey] = new URLPattern(current.props.path, urlPatternOptions);\n      }\n\n      if (!page) {\n        match = pattern.match(pathToMatch);\n\n        if (match) {\n          page = current;\n        } // Backcompat fix in 0.27: regexes in url-pattern no longer return {_: matches}\n\n\n        if (match && current.props.path instanceof RegExp && !match._ && Array.isArray(match)) {\n          match = {\n            _: match\n          };\n        } // Backcompat fix; url-pattern removed the array wrapper on wildcards\n\n\n        if (match && match._ != null && !Array.isArray(match._)) {\n          match._ = [match._];\n        }\n      }\n    }\n\n    if (!notFound && current.props.path === null) {\n      notFound = current;\n    }\n  }\n\n  return new Match(pathToMatch, page ? page : notFound ? notFound : null, match, queryObj, (urlPatternOptions || {}).namedSegmentValueDecoders);\n}\n/**\n * Match object\n *\n * @private\n */\n\n\nfunction Match(path, route, match, query, valueDecoders) {\n  this.path = path;\n  this.route = route;\n  this.match = match;\n  this.query = query;\n\n  if (valueDecoders) {\n    Object.keys(match || {}).forEach(function (key) {\n      if (typeof valueDecoders === 'function') {\n        match[key] = valueDecoders(key, match[key]);\n        return;\n      }\n\n      var fn = valueDecoders.hasOwnProperty(key) && valueDecoders[key];\n\n      if (typeof fn === 'function') {\n        match[key] = fn(match[key]);\n      }\n    });\n  }\n\n  this.unmatchedPath = this.match && this.match._ ? this.match._[0] : null;\n  this.matchedPath = this.unmatchedPath ? this.path.substring(0, this.path.length - this.unmatchedPath.length) : this.path;\n}\n\nvar EMPTY_OBJECT = {}; // Maintains reference equality, useful for SCU\n\nObject.freeze && Object.freeze(EMPTY_OBJECT);\n\nMatch.prototype.getProps = function () {\n  if (!this.route) {\n    throw new Error(\"React-router-component: No route matched! Did you define a NotFound route?\");\n  }\n\n  var props = assign({}, this.route.props, this.match); // Querystring is assigned as _query.\n\n  props._query = this.query || EMPTY_OBJECT; // Delete props that shouldn't be passed to the handler.\n\n  props = omit(props, ['pattern', 'path', 'handler']);\n  return props;\n};\n\nMatch.prototype.getHandler = function () {\n  if (!this.route) return undefined;\n  return this.route.props.handler;\n};\n\nmodule.exports = matchRoutes;","map":null,"metadata":{},"sourceType":"script"}