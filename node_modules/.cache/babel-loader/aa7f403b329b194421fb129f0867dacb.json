{"ast":null,"code":"\"use strict\";\n\nvar React = require('react');\n\nvar CreateReactClass = require('create-react-class');\n\nvar PropTypes = require('prop-types');\n\nvar urllite = require('urllite/lib/core');\n\nvar Environment = require('./environment');\n\nvar HashEnvironment = require('./environment/HashEnvironment');\n\nvar assign = Object.assign || require('object-assign');\n\nvar omit = require('object.omit');\n\nvar PROP_TYPES = {\n  component: PropTypes.oneOfType([PropTypes.string, PropTypes.func]).isRequired,\n  environment: PropTypes.object,\n  gotoURL: PropTypes.func\n};\nvar PROP_KEYS = Object.keys(PROP_TYPES);\n/**\n * A container component which captures <a> clicks and, if there's a matching\n * route defined, routes them.\n */\n\nvar CaptureClicks = CreateReactClass({\n  displayName: 'CaptureClicks',\n  propTypes: PROP_TYPES,\n  getDefaultProps: function () {\n    return {\n      component: 'div',\n      environment: Environment.defaultEnvironment,\n      gotoURL: function (url) {\n        // We should really just be allowing the event's default action, be we\n        // can't make the decision to do that synchronously.\n        window.location.href = url;\n      }\n    };\n  },\n  onClick: function (e) {\n    if (this.props.onClick) {\n      var shouldProceed = this.props.onClick(e);\n      if (shouldProceed === false) return;\n    } // Ignore canceled events, modified clicks, and right clicks.\n\n\n    if (e.defaultPrevented) {\n      return;\n    }\n\n    if (e.metaKey || e.ctrlKey || e.shiftKey) {\n      return;\n    }\n\n    if (e.button !== 0) {\n      return;\n    } // Get the <a> element.\n\n\n    var el = e.target;\n\n    while (el && el.nodeName !== 'A') {\n      el = el.parentNode;\n    } // Ignore clicks from non-a elements.\n\n\n    if (!el) {\n      return;\n    } // Ignore the click if the element has a target.\n\n\n    if (el.target && el.target !== '_self') {\n      return;\n    } // Ignore the click if it's a download link. (We use this method of\n    // detecting the presence of the attribute for old IE versions.)\n\n\n    if (el.attributes.download) {\n      return;\n    } // Ignore hash (used often instead of javascript:void(0) in strict CSP envs)\n\n\n    if (el.getAttribute('href') === '#' && !(this.props.environment instanceof HashEnvironment)) {\n      return;\n    } // Use a regular expression to parse URLs instead of relying on the browser\n    // to do it for us (because IE).\n\n\n    var url = urllite(el.href);\n    var windowURL = urllite(window.location.href); // Ignore links that don't share a protocol and host with ours.\n\n    if (url.protocol !== windowURL.protocol || url.host !== windowURL.host) {\n      return;\n    } // Ignore 'rel=\"external\"' links.\n\n\n    if (el.rel && /(?:^|\\s+)external(?:\\s+|$)/.test(el.rel)) {\n      return;\n    } // Prevent :focus from sticking; preventDefault() stops blur in some browsers\n\n\n    el.blur();\n    e.preventDefault(); // Mark if any of our routers matched. If they didn't, we'll call gotoURL.\n\n    var matched = false;\n\n    var onBeforeNavigation = function (path, navigation, match) {\n      if (match && match.match) {\n        matched = true;\n      }\n    };\n\n    var gotoURL = this.props.gotoURL;\n    this.props.environment.navigate(url.pathname + (url.search.length > 1 ? url.search : '') + (url.hash.length > 1 ? url.hash : ''), {\n      onBeforeNavigation: onBeforeNavigation\n    }, function (err, info) {\n      if (err) {\n        throw err;\n      } // No routers matched - so we'll escape out using gotoURL.\n\n\n      if (!matched) gotoURL(el.href);\n    });\n  },\n  render: function () {\n    var props = assign({}, this.props, {\n      onClick: this.onClick\n    });\n    props = omit(props, PROP_KEYS);\n    return React.createElement(this.props.component, props, this.props.children);\n  }\n});\nmodule.exports = CaptureClicks;","map":null,"metadata":{},"sourceType":"script"}