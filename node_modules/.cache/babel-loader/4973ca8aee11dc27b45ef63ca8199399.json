{"ast":null,"code":"\"use strict\";\n\nvar React = require('react');\n\nvar PropTypes = require('prop-types');\n\nvar invariant = require('./util/invariant');\n\nvar assign = Object.assign || require('object-assign');\n\nvar matchRoutes = require('./matchRoutes');\n\nvar Environment = require('./environment');\n\nvar shallowEqual = require('is-equal-shallow');\n\nvar RouterMixin = {\n  mixins: [Environment.Mixin],\n  propTypes: {\n    // Added by matches\n    _: PropTypes.array,\n    _query: PropTypes.object,\n    hash: PropTypes.bool,\n    // User props\n    path: PropTypes.string,\n    contextual: PropTypes.bool,\n    onBeforeNavigation: PropTypes.func,\n    onNavigation: PropTypes.func,\n    urlPatternOptions: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.object])\n  },\n  childContextTypes: {\n    router: PropTypes.any\n  },\n  getChildContext: function () {\n    return {\n      router: this\n    };\n  },\n  contextTypes: {\n    router: PropTypes.any\n  },\n  getInitialState: function () {\n    return this.getRouterState(this.props);\n  },\n  componentWillReceiveProps: function (nextProps) {\n    if (!shallowEqual(nextProps, this.props)) {\n      var nextState = this.getRouterState(nextProps);\n      this.delegateSetRoutingState(nextState);\n    }\n  },\n  getRouterState: function (props) {\n    var path;\n    var prefix;\n    var query;\n    var parent = props.contextual && this.getParentRouter();\n\n    if (parent) {\n      // Build our new path based off the parent. A navigation may be in progress, in which case\n      // we as well want the newest data so we use the pending match.\n      var parentMatch = parent._pendingMatch || parent.getMatch();\n      invariant(props.path || isString(parentMatch.unmatchedPath) || parentMatch.matchedPath === parentMatch.path, \"contextual router has nothing to match on: %s\", parentMatch.unmatchedPath);\n      path = props.path || parentMatch.unmatchedPath || '/';\n      prefix = parent.state.prefix + parentMatch.matchedPath;\n      query = parentMatch.query;\n    } else {\n      path = props.path || this.getEnvironment().getPath();\n      invariant(isString(path), \"router operate in environment which cannot provide path, \" + \"pass it a path prop; or probably you want to make it contextual\");\n      prefix = '';\n    }\n\n    if (path[0] !== '/') {\n      path = '/' + path;\n    }\n\n    var match = matchRoutes(this.getRoutes(props), path, query, this.getURLPatternOptions());\n    return {\n      match: match,\n      matchProps: match.getProps(),\n      handler: match.getHandler(),\n      prefix: prefix,\n      navigation: {},\n      path: path\n    };\n  },\n  getEnvironment: function () {\n    if (this.props.environment) {\n      return this.props.environment;\n    }\n\n    if (this.props.hash) {\n      return Environment.hashEnvironment;\n    }\n\n    if (this.props.contextual && this.context.router) {\n      return this.context.router.getEnvironment();\n    }\n\n    return Environment.defaultEnvironment;\n  },\n\n  /**\n   * Return parent router or undefined.\n   */\n  getParentRouter: function () {\n    var current = this.context.router;\n    var environment = this.getEnvironment();\n\n    if (current) {\n      if (current.getEnvironment() === environment) {\n        return current;\n      }\n    }\n  },\n\n  /**\n   * Return current match.\n   */\n  getMatch: function () {\n    return this.state.match;\n  },\n  getURLPatternOptions: function () {\n    var parent = this.getParentRouter();\n    var parentOptions = parent && parent.getURLPatternOptions(); // Check existence so we don't return an empty object if there are no options.\n\n    if (parentOptions) {\n      return assign({}, this.props.urlPatternOptions, parentOptions);\n    }\n\n    return this.props.urlPatternOptions;\n  },\n\n  /**\n   * Make href scoped for the current router.\n   */\n  makeHref: function (href) {\n    return join(this.state.prefix, href);\n  },\n\n  /**\n   * Navigate to a path\n   *\n   * @param {String} path\n   * @param {Function} navigation\n   * @param {Callback} cb\n   */\n  navigate: function (path, navigation, cb) {\n    path = join(this.state.prefix, path);\n    this.getEnvironment().setPath(path, navigation, cb);\n  },\n\n  /**\n   * Set new path.\n   *\n   * This function is called by environment.\n   *\n   * @private\n   *\n   * @param {String} path\n   * @param {Function} navigation\n   * @param {Callback} cb\n   */\n  setPath: function (path, navigation, cb) {\n    var state = this.getRouterState(this.props);\n    state.navigation = navigation;\n\n    if (this.props.onBeforeNavigation && this.props.onBeforeNavigation(state.path, navigation, state.match) === false) {\n      return;\n    }\n\n    if (navigation.onBeforeNavigation && navigation.onBeforeNavigation(state.path, navigation, state.match) === false) {\n      return;\n    }\n\n    this.delegateSetRoutingState(state, function () {\n      if (this.props.onNavigation) {\n        this.props.onNavigation(state.path, navigation, state.match);\n      }\n\n      cb();\n    }.bind(this));\n  },\n\n  /**\n   * Return the current path\n   */\n  getPath: function () {\n    return this.state.match.path;\n  },\n\n  /**\n   * Try to delegate state update to a setRoutingState method (might be provided\n   * by router itself) or use replaceState.\n   */\n  delegateSetRoutingState: function (state, cb) {\n    // Store this here so it can be accessed by child contextual routers in onBeforeNavigation.\n    this._pendingMatch = state.match;\n\n    if (this.setRoutingState) {\n      this.setRoutingState(state, cb);\n    } else {\n      this.setState(state, cb);\n    }\n  }\n};\n\nfunction join(a, b) {\n  return (a + b).replace(/\\/\\//g, '/');\n}\n\nfunction isString(o) {\n  return Object.prototype.toString.call(o) === '[object String]';\n}\n\nmodule.exports = RouterMixin;","map":null,"metadata":{},"sourceType":"script"}